<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Real-World Examples - The Complete JailedPath Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Complete JailedPath Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h1>
<p>This chapter shows practical, real-world scenarios where jailed-path helps secure your applications. Each example includes complete, runnable code that you can adapt to your own projects.</p>
<h2 id="web-file-upload-service"><a class="header" href="#web-file-upload-service">Web File Upload Service</a></h2>
<p>Let's build a simple file upload service that allows users to upload files safely:</p>
<pre><pre class="playground"><code class="language-rust">use jailed_path::{Jail, JailedPath};
use std::fs;
use std::io::{self, Write};

struct FileUploadService {
    uploads_jail: Jail,
}

impl FileUploadService {
    fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Create a jail for uploaded files
        let uploads_jail = Jail::try_new_create("user_uploads")?;
        Ok(Self { uploads_jail })
    }
    
    fn upload_file(&amp;self, filename: &amp;str, content: &amp;[u8]) -&gt; Result&lt;JailedPath, Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the filename is safe
        let safe_path = self.uploads_jail.jailed_join(filename)?;
        
        // Create parent directories if needed
        if let Some(parent) = safe_path.parent() {
            fs::create_dir_all(parent)?;
        }
        
        // Write the file safely
        fs::write(&amp;safe_path, content)?;
        
        println!("✅ File uploaded safely to: {}", safe_path.as_path().display());
        Ok(safe_path)
    }
    
    fn list_files(&amp;self) -&gt; Result&lt;Vec&lt;JailedPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut files = Vec::new();
        
        // Only iterate within the jail
        for entry in fs::read_dir(&amp;self.uploads_jail)? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                // Validate each path through the jail
                let safe_path = self.uploads_jail.jailed_join(entry.file_name())?;
                files.push(safe_path);
            }
        }
        
        Ok(files)
    }
    
    fn download_file(&amp;self, filename: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the requested filename
        let safe_path = self.uploads_jail.jailed_join(filename)?;
        
        // Read and return the file content
        let content = fs::read(&amp;safe_path)?;
        Ok(content)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let service = FileUploadService::new()?;
    
    // Simulate user uploads - these are all SAFE
    service.upload_file("document.txt", b"Hello, world!")?;
    service.upload_file("reports/january.pdf", b"PDF content here")?;
    service.upload_file("images/photo.jpg", b"JPEG data")?;
    
    // These would FAIL with directory traversal protection:
    // service.upload_file("../../../etc/passwd", b"attack")?;  // ❌ Blocked!
    // service.upload_file("..\\windows\\system32\\evil.exe", b"malware")?;  // ❌ Blocked!
    
    // List uploaded files
    println!("📁 Uploaded files:");
    for file in service.list_files()? {
        println!("  - {}", file.as_path().display());
    }
    
    // Download a file
    let content = service.download_file("document.txt")?;
    println!("📄 Downloaded: {}", String::from_utf8_lossy(&amp;content));
    
    Ok(())
}</code></pre></pre>
<h2 id="configuration-file-manager"><a class="header" href="#configuration-file-manager">Configuration File Manager</a></h2>
<p>Here's how to safely handle user configuration files:</p>
<pre><pre class="playground"><code class="language-rust">use jailed_path::{Jail, JailedPath};
use serde::{Deserialize, Serialize};
use std::fs;

#[derive(Serialize, Deserialize, Debug)]
struct AppConfig {
    theme: String,
    language: String,
    auto_save: bool,
}

impl Default for AppConfig {
    fn default() -&gt; Self {
        Self {
            theme: "dark".to_string(),
            language: "en".to_string(),
            auto_save: true,
        }
    }
}

struct ConfigManager {
    config_jail: Jail,
}

impl ConfigManager {
    fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Create a jail for configuration files
        let config_jail = Jail::try_new_create("app_config")?;
        Ok(Self { config_jail })
    }
    
    fn load_config(&amp;self, config_name: &amp;str) -&gt; Result&lt;AppConfig, Box&lt;dyn std::error::Error&gt;&gt; {
        // Ensure the config file name is safe
        let config_path = self.config_jail.jailed_join(config_name)?;
        
        // Load config or create default
        if config_path.exists() {
            let content = fs::read_to_string(&amp;config_path)?;
            let config: AppConfig = serde_json::from_str(&amp;content)?;
            println!("📖 Loaded config from: {}", config_path.as_path().display());
            Ok(config)
        } else {
            println!("🆕 Creating default config at: {}", config_path.as_path().display());
            let default_config = AppConfig::default();
            self.save_config(config_name, &amp;default_config)?;
            Ok(default_config)
        }
    }
    
    fn save_config(&amp;self, config_name: &amp;str, config: &amp;AppConfig) -&gt; Result&lt;JailedPath, Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the config file path
        let config_path = self.config_jail.jailed_join(config_name)?;
        
        // Serialize and save
        let content = serde_json::to_string_pretty(config)?;
        fs::write(&amp;config_path, content)?;
        
        println!("💾 Saved config to: {}", config_path.as_path().display());
        Ok(config_path)
    }
    
    fn list_configs(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut configs = Vec::new();
        
        for entry in fs::read_dir(&amp;self.config_jail)? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                if let Some(name) = entry.file_name().to_str() {
                    if name.ends_with(".json") {
                        configs.push(name.to_string());
                    }
                }
            }
        }
        
        Ok(configs)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let config_manager = ConfigManager::new()?;
    
    // Load or create user config
    let mut user_config = config_manager.load_config("user.json")?;
    println!("Current config: {:#?}", user_config);
    
    // Modify and save
    user_config.theme = "light".to_string();
    user_config.auto_save = false;
    config_manager.save_config("user.json", &amp;user_config)?;
    
    // Create a different profile
    let admin_config = AppConfig {
        theme: "admin".to_string(),
        language: "en".to_string(),
        auto_save: true,
    };
    config_manager.save_config("admin.json", &amp;admin_config)?;
    
    // List all configs
    println!("📋 Available configs: {:?}", config_manager.list_configs()?);
    
    // These attempts would be blocked:
    // config_manager.load_config("../../../etc/passwd")?;  // ❌ Blocked!
    // config_manager.save_config("..\\windows\\evil.json", &amp;user_config)?;  // ❌ Blocked!
    
    Ok(())
}</code></pre></pre>
<h2 id="multi-user-document-storage-with-virtualpath"><a class="header" href="#multi-user-document-storage-with-virtualpath">Multi-User Document Storage with VirtualPath</a></h2>
<p>For applications where each user should feel like they have their own filesystem:</p>
<pre><pre class="playground"><code class="language-rust">use jailed_path::{VirtualRoot, VirtualPath};
use std::fs;
use std::collections::HashMap;

struct DocumentStore {
    user_roots: HashMap&lt;String, VirtualRoot&gt;,
}

impl DocumentStore {
    fn new() -&gt; Self {
        Self {
            user_roots: HashMap::new(),
        }
    }
    
    fn get_user_root(&amp;mut self, username: &amp;str) -&gt; Result&lt;&amp;VirtualRoot, Box&lt;dyn std::error::Error&gt;&gt; {
        if !self.user_roots.contains_key(username) {
            // Each user gets their own isolated storage
            let user_dir = format!("user_data_{}", username);
            let vroot = VirtualRoot::try_new_create(&amp;user_dir)?;
            self.user_roots.insert(username.to_string(), vroot);
            println!("🏠 Created virtual root for user: {}", username);
        }
        
        Ok(self.user_roots.get(username).unwrap())
    }
    
    fn save_document(&amp;mut self, username: &amp;str, virtual_path: &amp;str, content: &amp;str) -&gt; Result&lt;VirtualPath, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.get_user_root(username)?;
        
        // User thinks they're saving to their own filesystem starting from "/"
        let doc_path = user_root.virtual_join(virtual_path)?;
        
        // Create parent directories if needed
        if let Some(parent) = doc_path.parent() {
            fs::create_dir_all(parent)?;
        }
        
        // Save the document
        fs::write(&amp;doc_path, content)?;
        
        println!("📝 User {} saved document to: {}", username, virtual_path);
        println!("    (Actually stored at: {})", doc_path.as_path().display());
        
        Ok(doc_path)
    }
    
    fn load_document(&amp;mut self, username: &amp;str, virtual_path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.get_user_root(username)?;
        let doc_path = user_root.virtual_join(virtual_path)?;
        
        let content = fs::read_to_string(&amp;doc_path)?;
        println!("📖 User {} loaded document from: {}", username, virtual_path);
        
        Ok(content)
    }
    
    fn list_user_documents(&amp;mut self, username: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.get_user_root(username)?;
        let mut docs = Vec::new();
        
        fn collect_files(dir: &amp;std::path::Path, base: &amp;std::path::Path, docs: &amp;mut Vec&lt;String&gt;) -&gt; std::io::Result&lt;()&gt; {
            for entry in fs::read_dir(dir)? {
                let entry = entry?;
                let path = entry.path();
                
                if path.is_file() {
                    if let Ok(relative) = path.strip_prefix(base) {
                        if let Some(path_str) = relative.to_str() {
                            docs.push(format!("/{}", path_str.replace("\\", "/")));
                        }
                    }
                } else if path.is_dir() {
                    collect_files(&amp;path, base, docs)?;
                }
            }
            Ok(())
        }
        
        collect_files(user_root.as_path(), user_root.as_path(), &amp;mut docs)?;
        Ok(docs)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut store = DocumentStore::new();
    
    // Alice saves some documents
    store.save_document("alice", "/reports/quarterly.txt", "Q1 revenue was strong")?;
    store.save_document("alice", "/notes/meeting.md", "# Meeting Notes\n- Discuss new features")?;
    store.save_document("alice", "/drafts/proposal.doc", "Project proposal draft")?;
    
    // Bob saves his documents (completely separate from Alice)
    store.save_document("bob", "/code/main.rs", "fn main() { println!(\"Hello!\"); }")?;
    store.save_document("bob", "/docs/readme.txt", "My awesome project")?;
    
    // Charlie tries to access Alice's files - this is blocked at the path level
    // store.save_document("charlie", "/../alice/reports/quarterly.txt", "hacked")?;  // ❌ Blocked!
    
    // Each user can access their own files
    println!("📄 Alice's quarterly report: {}", store.load_document("alice", "/reports/quarterly.txt")?);
    println!("💻 Bob's code: {}", store.load_document("bob", "/code/main.rs")?);
    
    // List each user's documents
    println!("📁 Alice's documents: {:?}", store.list_user_documents("alice")?);
    println!("📁 Bob's documents: {:?}", store.list_user_documents("bob")?);
    
    Ok(())
}</code></pre></pre>
<h2 id="archive-extraction-with-safety"><a class="header" href="#archive-extraction-with-safety">Archive Extraction with Safety</a></h2>
<p>Safely extract ZIP files and other archives without zip-slip vulnerabilities:</p>
<pre><pre class="playground"><code class="language-rust">use jailed_path::{Jail, JailedPath};
use std::fs;
use std::io::Write;

struct SafeArchiveExtractor {
    extraction_jail: Jail,
}

impl SafeArchiveExtractor {
    fn new(extract_to: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let extraction_jail = Jail::try_new_create(extract_to)?;
        Ok(Self { extraction_jail })
    }
    
    fn extract_entry(&amp;self, entry_path: &amp;str, content: &amp;[u8]) -&gt; Result&lt;JailedPath, Box&lt;dyn std::error::Error&gt;&gt; {
        // This automatically prevents zip-slip attacks
        let safe_path = self.extraction_jail.jailed_join(entry_path)?;
        
        // Create parent directories
        if let Some(parent) = safe_path.parent() {
            fs::create_dir_all(parent)?;
        }
        
        // Write the file
        fs::write(&amp;safe_path, content)?;
        
        println!("📦 Extracted: {} -&gt; {}", entry_path, safe_path.as_path().display());
        Ok(safe_path)
    }
    
    fn extract_mock_zip(&amp;self) -&gt; Result&lt;Vec&lt;JailedPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        // Simulate extracting a ZIP file with various entries
        let entries = vec![
            ("readme.txt", b"Welcome to our software!"),
            ("src/main.rs", b"fn main() { println!(\"Hello!\"); }"),
            ("docs/api.md", b"# API Documentation"),
            ("config/settings.json", b"{ \"debug\": true }"),
            
            // These malicious entries would be automatically blocked:
            // ("../../../etc/passwd", b"hacked"),           // ❌ Blocked!
            // ("..\\windows\\system32\\evil.exe", b"malware"), // ❌ Blocked!
            // ("/absolute/path/hack.txt", b"bad"),          // ❌ Blocked!
        ];
        
        let mut extracted_files = Vec::new();
        
        for (entry_path, content) in entries {
            match self.extract_entry(entry_path, content) {
                Ok(safe_path) =&gt; extracted_files.push(safe_path),
                Err(e) =&gt; println!("⚠️  Blocked malicious entry '{}': {}", entry_path, e),
            }
        }
        
        Ok(extracted_files)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let extractor = SafeArchiveExtractor::new("extracted_files")?;
    
    println!("🗃️  Extracting archive safely...");
    let extracted = extractor.extract_mock_zip()?;
    
    println!("\n✅ Successfully extracted {} files:", extracted.len());
    for file in &amp;extracted {
        println!("   📄 {}", file.as_path().display());
    }
    
    // Verify we can read the extracted files
    for file in &amp;extracted {
        if file.as_path().extension().and_then(|s| s.to_str()) == Some("txt") {
            let content = fs::read_to_string(file)?;
            println!("📖 {}: {}", file.as_path().display(), content.trim());
        }
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="cli-tool-with-safe-path-handling"><a class="header" href="#cli-tool-with-safe-path-handling">CLI Tool with Safe Path Handling</a></h2>
<p>A command-line tool that processes user-provided file paths safely:</p>
<pre><pre class="playground"><code class="language-rust">use jailed_path::{Jail, JailedPath};
use std::env;
use std::fs;

struct SafeFileProcessor {
    working_jail: Jail,
}

impl SafeFileProcessor {
    fn new(working_directory: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Create or validate the working directory
        let working_jail = Jail::try_new_create(working_directory)?;
        println!("🔒 Working directory jail: {}", working_jail.as_path().display());
        Ok(Self { working_jail })
    }
    
    fn process_file(&amp;self, relative_path: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the user-provided path
        let safe_path = self.working_jail.jailed_join(relative_path)?;
        
        if !safe_path.exists() {
            return Err(format!("File not found: {}", relative_path).into());
        }
        
        // Process the file (example: count lines)
        let content = fs::read_to_string(&amp;safe_path)?;
        let line_count = content.lines().count();
        let word_count = content.split_whitespace().count();
        let char_count = content.chars().count();
        
        println!("📊 Statistics for {}:", relative_path);
        println!("   Lines: {}", line_count);
        println!("   Words: {}", word_count);
        println!("   Characters: {}", char_count);
        
        Ok(())
    }
    
    fn create_sample_files(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Create some sample files for testing
        let samples = vec![
            ("sample1.txt", "Hello world!\nThis is a test file.\nWith multiple lines."),
            ("data/sample2.txt", "Another file\nwith some content\nfor processing."),
            ("docs/readme.md", "# Sample Project\n\nThis is a sample markdown file."),
        ];
        
        for (path, content) in samples {
            let safe_path = self.working_jail.jailed_join(path)?;
            if let Some(parent) = safe_path.parent() {
                fs::create_dir_all(parent)?;
            }
            fs::write(&amp;safe_path, content)?;
            println!("📝 Created: {}", path);
        }
        
        Ok(())
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let args: Vec&lt;String&gt; = env::args().collect();
    
    if args.len() &lt; 2 {
        println!("Usage: {} &lt;file-path&gt;", args[0]);
        println!("       {} --create-samples", args[0]);
        return Ok(());
    }
    
    // Set up our safe processor
    let processor = SafeFileProcessor::new("workspace")?;
    
    if args[1] == "--create-samples" {
        processor.create_sample_files()?;
        println!("✅ Sample files created in workspace/");
        return Ok(());
    }
    
    // Process the user-specified file
    let file_path = &amp;args[1];
    
    match processor.process_file(file_path) {
        Ok(()) =&gt; println!("✅ File processed successfully!"),
        Err(e) =&gt; {
            println!("❌ Error processing file: {}", e);
            
            if file_path.contains("..") || file_path.starts_with('/') || file_path.contains('\\') {
                println!("💡 Tip: Use relative paths within the workspace directory only.");
                println!("   Trying to escape the workspace? That's not allowed! 🔒");
            }
        }
    }
    
    Ok(())
}

// Example usage:
// cargo run -- --create-samples
// cargo run -- sample1.txt                    # ✅ Works
// cargo run -- data/sample2.txt              # ✅ Works  
// cargo run -- ../../../etc/passwd           # ❌ Blocked!
// cargo run -- /absolute/path/hack.txt       # ❌ Blocked!</code></pre></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>These examples show how jailed-path helps in real scenarios:</p>
<ol>
<li><strong>Web uploads</strong>: Users can't escape the upload directory</li>
<li><strong>Configuration</strong>: Config files stay in their designated area</li>
<li><strong>Multi-user</strong>: Each user gets isolated storage that feels like their own filesystem</li>
<li><strong>Archive extraction</strong>: Automatic protection against zip-slip attacks</li>
<li><strong>CLI tools</strong>: User-provided paths are validated safely</li>
</ol>
<p>The common pattern is:</p>
<ol>
<li>Create a <code>Jail</code> or <code>VirtualRoot</code> for your safe area</li>
<li>Always validate external paths through <code>jailed_join()</code> or <code>virtual_join()</code></li>
<li>Use the resulting <code>JailedPath</code> or <code>VirtualPath</code> for file operations</li>
<li>Let the compiler enforce that only validated paths are used</li>
</ol>
<p>This makes your code both secure and maintainable - security isn't something you have to remember to check, it's built into the type system!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="archive_extractors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="archive_extractors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
